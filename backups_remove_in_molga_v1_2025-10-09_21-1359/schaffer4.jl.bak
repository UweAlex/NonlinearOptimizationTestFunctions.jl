# src/functions/schaffer4.jl
# Purpose: Implementation of the Schaffer Function No. 4 test function.
# Global minimum: f(x*)=0.29257863203598 at x*=(0, 1.253131828792882).
# Bounds: -100 ≤ x_i ≤ 100.

export SCHAFFER4_FUNCTION, schaffer4, schaffer4_gradient

function schaffer4(x::AbstractVector{T}) where {T<:Union{Real, ForwardDiff.Dual}}
    n = length(x)
    func_name = basename(@__FILE__)[1:end-3]  # Dynamisch: "schaffer4" für Konsistenz [RULE_NAME_CONSISTENCY]
    n == 0 && throw(ArgumentError("Input vector cannot be empty"))
    n != 2 && throw(ArgumentError("$(func_name) requires exactly 2 dimensions"))  # Dynamischer Fehlertext [RULE_ERROR_TEXT_DYNAMIC]
    any(isnan.(x)) && return T(NaN)
    any(isinf.(x)) && return T(Inf)
    
    x1, x2 = x
    u = x1^2 - x2^2
    inner = abs(u)
    g = sin(inner)
    h = cos(g)^2
    num = h - 0.5
    r = x1^2 + x2^2
    q = 1.0 + 0.001 * r
    denom = q^2
    0.5 + num / denom
end

function schaffer4_gradient(x::AbstractVector{T}) where {T<:Union{Real, ForwardDiff.Dual}}
    n = length(x)
    func_name = basename(@__FILE__)[1:end-3]  # Dynamisch: "schaffer4" [RULE_NAME_CONSISTENCY]
    n == 0 && throw(ArgumentError("Input vector cannot be empty"))
    n != 2 && throw(ArgumentError("$(func_name) requires exactly 2 dimensions"))  # Dynamisch [RULE_ERROR_TEXT_DYNAMIC]
    any(isnan.(x)) && return fill(T(NaN), n)
    any(isinf.(x)) && return fill(T(Inf), n)
    
    grad = zeros(T, 2)  # [RULE_GRADTYPE]
    x1, x2 = x
    u = x1^2 - x2^2
    s_u = sign(u)
    inner = abs(u)
    g = sin(inner)
    sin_2g = sin(2 * g)
    cos_inner = cos(inner)
    num = cos(g)^2 - 0.5
    r = x1^2 + x2^2
    q = 1.0 + 0.001 * r
    denom = q^2
    denom_sq = denom^2
    
    # dnum_dx1 = -sin_2g * dg_dx1
    dg_dx1 = cos_inner * (s_u * 2 * x1)
    dnum_dx1 = -sin_2g * dg_dx1
    
    # dnum_dx2
    dg_dx2 = cos_inner * (s_u * (-2 * x2))
    dnum_dx2 = -sin_2g * dg_dx2
    
    # ddenom_dx1 = 0.004 * q * x1
    ddenom_dx1 = 0.004 * q * x1
    ddenom_dx2 = 0.004 * q * x2
    
    # df_dx1 = (dnum_dx1 * denom - num * ddenom_dx1) / denom^2
    grad[1] = (dnum_dx1 * denom - num * ddenom_dx1) / denom_sq
    grad[2] = (dnum_dx2 * denom - num * ddenom_dx2) / denom_sq
    
    grad
end

const SCHAFFER4_FUNCTION = TestFunction(
    schaffer4,
    schaffer4_gradient,
    Dict(
        :name => basename(@__FILE__)[1:end-3],  # Dynamisch: "schaffer4" – exakt Dateiname [RULE_NAME_CONSISTENCY]
        :description => "Schaffer Function No. 4 (with absolute value); Formel, Minimum and Bounds from Al-Roomi (2015); Properties adapted from Jamil & Yang (2013, p. 28) for similar variant (without | |); ursprünglich aus Schaffer (1984).",
        :math => raw"""f(\mathbf{x}) = 0.5 + \frac{\cos^2 \left( \sin \left( |x_1^2 - x_2^2| \right) \right) - 0.5}{\left[ 1 + 0.001 (x_1^2 + x_2^2) \right]^2}. """,
        :start => () -> [0.0, 0.0],
        :min_position => () -> [0.0, 1.253131828792882],
        :min_value => () -> 0.29257863203598,
        :properties => ["continuous", "differentiable", "non-separable", "unimodal"],
        :source => "Al-Roomi (2015)",
        :lb => () -> [-100.0, -100.0],
        :ub => () -> [100.0, 100.0],
    )
)