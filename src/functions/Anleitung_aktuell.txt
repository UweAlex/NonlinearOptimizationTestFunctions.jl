```
# Erweiterte Anleitung: Hinzuf√ºgen einer neuen Testfunktion (mit Templates, Properties-Liste und strengen Regeln)

Diese Anleitung basiert auf der urspr√ºnglichen Version und ist verbessert durch Integration von maschinenlesbaren Regeln (RFC-2119-Keywords: MUST, SHOULD, MAY), Tags f√ºr Suchbarkeit, thematische Gruppierung, Beispiele und Automatisierungs-Hinweise. Redundanz ist beabsichtigt f√ºr Klarheit. Die Regeln f√∂rdern Konsistenz, reduzieren Fehler und machen die Anleitung KI-freundlich. Wichtige Regeln werden wiederholt. Neu: Erg√§nzungen zu h√§ufigen Syntax-Pitfalls in Meta-Funktionen und Tests, basierend auf realen Fehlern (z.B. Signatur-Mismatches bei :min_value und Vektor-Vergleichen).  F√ºr skalierbare Funktionen: Integriere :default_n als Meta-Feld, um eine Standarddimension f√ºr Tests und Dokumentation zu definieren.  Noise-Handling: F√ºr Funktionen mit "has_noise" (z.B. Quartic), passe Validierungen an, um stochastische Effekte zu ber√ºcksichtigen ‚Äì exakte Gleichheit ist unm√∂glich; verwende Range-Checks statt atol.  [RULE_SOURCE_FORMULA_CONSISTENCY] MUST: Die Quellen f√ºr :properties M√úSSEN die exakt gleiche Funktionsformel verwenden wie die implementierte Version (z.B. gleiche Reihenfolge der trigonometrischen Funktionen, exakte Denominator-Struktur). Wenn keine exakte √úbereinstimmung verf√ºgbar, adaptiere Properties nur aus der n√§chstverwandten Quelle und notiere die Abweichung explizit in :description (z.B. "Properties adapted from [Quelle] for variant without absolute value"). Suche bei Bedarf weitere Quellen, die die pr√§zise Formel abdecken, aber priorisiere Konsistenz √ºber Vollst√§ndigkeit.

## Grundprinzipien
 - Verwende RFC-2119-Keywords: MUST (verpflichtend), SHOULD (empfohlen), MAY (optional).
 - Suche nach Tags wie [RULE_SIGNATURE] f√ºr schnelle Referenz.
 - Automatisierte Checks: F√ºhre vor jedem Commit CI-Skripte aus (z.B. Syntax-Check mit julia --project=. -e 'include("src/functions/<name>.jl")' + Namens-Check: julia --project=. -e 'tf = <UPPER>_FUNCTION; @test tf.meta[:name] == "<name>"').
 - Wiederhole kritische Regeln: z.B. Vermeide globale Konstanten [RULE_NO_CONST_ARRAYS].
 - Assume gute Absicht: Keine moralisierenden Kommentare; fokussiere auf Fakten.
 - [RULE_META_CONSISTENCY] MUST: Alle Meta-Funktionen (:start, :min_position, :min_value, :lb, :ub) m√ºssen konsistente Signaturen haben. F√ºr skalierbare Funktionen: Wenn der Wert von n unabh√§ngig ist (z.B. konstantes Minimum), verwende (n::Int) -> value (ignoriere n intern). Wenn abh√§ngig (z.B. Position sqrt.(1:n)), verwende (n::Int) -> ... . Teste im REPL: tf.meta[:min_value](2) ‚Äì muss funktionieren; tf.meta[:min_value]() darf MethodError werfen, da runtests.jl f√ºr scalable n aufruft.  F√ºr konstante Werte in skalierbaren Funktionen (z.B. min_value=0.0 unabh√§ngig von n): Verwende (n::Int) -> value, um MethodError in runtests.jl zu vermeiden (Aufruf mit n bei ()-Signatur).
 - [RULE_DEFAULT_N] MUST f√ºr skalierbare Funktionen: Setze :default_n => Integer im Meta-Dict. Der Wert MUST >= 2 sein und das kleinste m√∂gliche n > 1 f√ºr die Funktion darstellen (z.B. 4 f√ºr Funktionen, die in Bl√∂cken von 4 skaliert werden, wie PowellSingular2; 2 f√ºr allgemein skalierbare wie Ackley). Verwende es in Tests und Dokumentation (z.B. print_function_properties.jl) als Standard-n f√ºr Anzeigen und Validierungen. SHOULD: Validiere im Test, dass tf.f mit n=default_n type-stable ist (@code_warntype tf.f(rand(n))).
 - [NEW RULE_NOISE_HANDLING] MUST: F√ºr Funktionen mit "has_noise" in :properties (z.B. Quartic mit uniform [0,1)-Noise): In runtests.jl und funktionsspezifischen Tests Range-Checks verwenden (z.B. f(min_pos) >= 0 && <1) statt f(min_pos) ‚âà 0 atol=1e-8. Dokumentiere Noise-Details in :description (z.B. "Additive uniform [0,1) noise"). Gradient bleibt deterministisch (nur f betroffen).

## Recherche und Validierung
Ziel: Sammle genaue Daten zu Minima, Werten, Schranken und Properties aus zuverl√§ssigen Quellen. Vermeide Rundungen.

 - [RULE_PROPERTIES_SOURCE] MUST: Notiere :source im Meta-Dict immer als die **direkte Quelle**, aus der die spezifischen Details (Formel, Minimum, Bounds, Properties) tats√§chlich √ºbernommen wurden (z.B. "Jamil & Yang (2013, p. 27)" f√ºr die Sargan-Funktion). Priorisiere umfassende Quellen wie Jamil & Yang ( https://arxiv.org/pdf/1308.4008 ) f√ºr Modality/Separability. Validiere Properties gegen diese Quelle; bei Abweichungen notiere in :description ("Adapted from [Quelle]").  Gib immer eine spezifische Stelle an (z.B. "p. 27" oder "Section 3.2"), um die √úbernahme nachvollziehbar zu machen. Vermeide mutma√üliche Ursprungsquellen (z.B. Dixon & Szeg√∂ (1978) f√ºr Sargan) als prim√§re :source ‚Äì erw√§hne sie nur in :description als historischen Kontext.  [RULE_SOURCE_FORMULA_CONSISTENCY] Wiederholung: Properties-Quellen M√úSSEN die exakt gleiche Formel verwenden; bei Varianten (z.B. mit/ohne Absolutwert) notiere "Adapted for [spezifische Abweichung]" und suche ggf. alternative Quellen.
 - SHOULD: Pr√ºfe ill-conditioning mit cond(ForwardDiff.hessian(tf.f, min_pos)) < 1e6; bei hoher Kondition f√ºge "ill-conditioned" zu Properties hinzu.  F√ºr noisy Funktionen: Ignoriere Noise in Hessian-Check (z.B. setze rand()=0 tempor√§r).
 - MAY: F√ºr komplexe Funktionen (z.B. Cola) erstelle Validierungs-Skripte (z.B. build_xy testen).
 - [RULE_RULE_MIN_VALUE_INDEPENDENT] SHOULD: F√ºr skalierbare Funktionen mit konstantem globalem Minimum (z.B. Qing: immer 0.0), setze :min_value = (n::Int) -> 0.0, auch wenn :min_position (n::Int) -> ... ist (ignoriere n). Beispiel: In Jamil & Yang ( https://arxiv.org/pdf/1308.4008 , p. 29) ist Qing multimodal, aber Minimum konstant ‚Äì keine n-Abh√§ngigkeit.  F√ºr noisy konstante Minima (z.B. Quartic: deterministisch 0, plus Noise): Verwende (n::Int) -> 0.0 als deterministischen Wert; validiere in Tests mit Noise-Range.
 -  F√ºr :default_n: Bestimme basierend auf der Funktion (z.B. kleinste n>1, bei der die Funktion definiert ist und Properties gelten; >=2). Validiere: tf.meta[:min_position](default_n) muss funktionieren ohne Error. F√ºr block-skalierbare (z.B. n%4==0): Setze default_n=4.

Quellen-Liste (erweitert):
 - Jamil & Yang (2013): https://arxiv.org/abs/1308.4008 (prim√§r f√ºr Properties; zitiere immer mit spezifischer Seite, z.B. "Jamil & Yang (2013, p. 27)").
 - Al-Roomi (2015): https://www.al-roomi.org/benchmarks/unconstrained.
 - Weitere: sfu.ca/~ssurjano, geatbx.com, MVF-Library (Adorio & Diliman, 2005).

H√§ufige Fehler (konsolidiert mit Beispielen):
- Meta-Typ-Scope-Fehler: Verwendung von T() in Meta-Funktionen (z. B. fill(T(1.0), n) in :start) f√ºhrt zu UndefVarError(:T), da Meta-Funktionen au√üerhalb des where-Kontexts definiert sind. L√∂sung: Verwende immer Float64-Literale (z. B. fill(1.0, n), zeros(n)). Julia konvertiert bei Bedarf in tf.f(tf.meta[:start](n)). Beispiel: In skalierbaren Funktionen: :start => (n::Int) -> fill(1.0, n). Validiere im REPL: tf.meta[:start](2) ‚Äì muss Vector{Float64} ohne Error zur√ºckgeben.
- Automatisierbar: CI-Check: julia --project=. -e 'include("src/functions/<name>.jl"); tf = <UPPER>_FUNCTION; @test eltype(tf.meta[:start](2)) == Float64'.
 - Ungenaue Minima: Berechne exakt via REPL (z.B. tf.f(min_pos) ‚âà min_value atol=1e-8).  F√ºr Noise: Verwende multiple Runs und Mittelwert; vermeide atol in runtests.jl.
 - Namenskonflikte: Vermeide T als Konstante (kollidiert mit Typ T).
 - Globale Constants: [RULE_NO_CONST_ARRAYS] MUST ‚Äì Keine globalen const-Arrays; lokale let-Bl√∂cke verwenden. Beispiel: Bei multi-include (devilliersglasser1/2) √ºberschreiben sich Werte.
 -  Meta-Signatur-Mismatch: Falsche Signatur f√ºr :min_value in skalierbaren Funktionen f√ºhrt zu MethodError (z.B. Aufruf mit n bei ()-Signatur). L√∂sung: √úberpr√ºfe mit REPL: julia> using NonlinearOptimizationTestFunctions; tf = QING_FUNCTION; tf.meta[:min_value](2).
 -  Test-Syntax-Fehler: all(vec .‚âà 0, atol=1e-8) schl√§gt fehl, da all() kein atol akzeptiert. Verwende all(isapprox.(vec, 0, atol=1e-8)).
 -  Noise-Validation-Fehler: In runtests.jl schl√§gt f(min_pos) ‚âà 0 atol=1e-6 fehl durch rand() (z.B. Quartic). L√∂sung: F√ºge if "has_noise" in properties: @test f_val >=0 && f_val <1 (f√ºr [0,1)-Noise).
 -  Dynamik in AD-Pfad: basename(@__FILE__) in f/grad oder Meta f√ºhrt zu Zygote.CompileError bei Hessian-Tests (QuoteNode-Assertion). L√∂sung: Hartkodierte Strings (z.B. "sphere requires..."); basename nur in CI/Assert.
 -  Name-Inkonsistenz bei hartkodiert: Tippfehler in "sphere" vs. Datei "shpere.jl" ‚Äì L√∂sung: Optional @assert "<name>" == basename(@__FILE__)[1:end-3] + CI-Regex-Check ('sphere requires' in sphere.jl).
 -  Redundante T()-Konvertierungen: `T(0.5)` in Formeln f√ºhrt zu leichten Instabilit√§ten. L√∂sung: Entferne sie; Julia inferiert automatisch. Beispiel: In Schaffer1: `T(0.5) + numerator / denominator` ‚Üí `0.5 + numerator / denominator`.
 -  Inkonsistente Quellen: Properties aus Quelle mit abweichender Formel (z.B. sin^2(cos) vs. cos^2(sin)) ‚Äì L√∂sung: Suche exakte Matches oder notiere Adaption in :description per [RULE_SOURCE_FORMULA_CONSISTENCY].
 -  Namenskonflikte in lokalen Hilfsfunktionen: Lokale `rastrigin`-Funktion √ºberschreibt globale ‚Üí L√∂sung: Pr√§fix `_shubert_hybrid_rastrigin_rastrigin_component`. Pr√ºfe mit `grep -r "function rastrigin" src/` vor Commit.

## Erlaubte Properties (VALID_PROPERTIES)
MUST: Nur aus dieser Liste verwenden. Erweitere Set und Readme bei Bedarf (PR mit Quelle).
SHOULD: F√ºr separable: "separable" (z.B. Bohachevsky1). Erg√§nze :source.

Tabelle (mit Beschreibungen und Beispielen):

| Property                  | Beschreibung                                                                 | Beispiele (Funktionen)          |
|---------------------------|-----------------------------------------------------------------------------|---------------------------------|
| bounded                  | Hat definierte Schranken (:lb, :ub).                                        | Branin, Bohachevsky2            |
| continuous               | Kontinuierlich √ºberall.                                                     | Ackley, Rosenbrock              |
| controversial            | Minimum umstritten (z. B. mehrere Quellen).                                 | Langermann                      |
| convex                   | Konvex (globales Minimum = einziges).                                       | Sphere                          |
| deceptive                | T√§uscht lokale Optima vor.                                                  | -                               |
| differentiable           | Differenzierbar √ºberall.                                                    | Rosenbrock                      |
| finite_at_inf            | Endlicher Wert bei ¬±‚àû.                                                      | -                               |
| fully non-separable      | Vollst√§ndig nicht-separabel.                                                | -                               |
| has_constraints          | Hat Nebenbedingungen.                                                       | -                               |
| has_noise                | Stochastisch/noisy.                                                         | Quartic                         |
| highly multimodal        | Stark multimodal (viele Local Minima).                                      | Rastrigin                       |
| multimodal               | Mehrere Local Minima.                                                       | Branin                          |
| non-convex               | Nicht-konvex.                                                               | Ackley                          |
| non-separable            | Nicht-separabel (Variablen gekoppelt).                                      | Rosenbrock                      |
| partially differentiable | Teilweise differenzierbar.                                                  | BartelsConn                     |
| partially separable      | Teilweise separabel.                                                        | -                               |
| quasi-convex             | Quasi-konvex.                                                               | -                               |
| scalable                 | Skalierbar (beliebige n).                                                   | Ackley, Rastrigin               |
| separable                | Separabel (unabh√§ngige Variablen).                                          | Sphere, Bohachevsky1            |
| strongly convex          | Stark konvex.                                                               | Quadratic                       |
| unimodal                 | Unimodal (ein Global Minimum).                                              | Sphere                          |
| ill-conditioned          | Schlecht konditioniert (hohe Cond-Number).                                  | Rosenbrock                      |

## Umgang mit fehlenden Properties

[RULE_MISSING_PROPERTIES]: Wenn Jamil & Yang eine Property nennt, die nicht in VALID_PROPERTIES ist:
1. Verwende nur die Properties, die in VALID_PROPERTIES existieren
2. Dokumentiere fehlende Properties in :description (z.B. "Contains absolute value terms" statt "non-differentiable")
3. Erstelle KEINE neuen Properties ohne vorherige Erweiterung von VALID_PROPERTIES
4.  Stelle sicher, dass die Formel in der Quelle exakt passt [RULE_SOURCE_FORMULA_CONSISTENCY]; bei Varianten suche alternative Quellen.

Beispiel: Price Function 1 ist laut Jamil & Yang (2013, p. 32) "non-differentiable, separable, non-scalable"
‚Üí Verwende: ["continuous", "separable", "multimodal"]
‚Üí In :description erw√§hnen: "Contains absolute value terms"

## Code-Struktur und Implementierung
Ziel: Erstelle <name>.jl mit konsistenter Signatur, ohne externe Deps.

### [RULE_PROPERTIES_CONSISTENCY] MUST ‚Äì H√∂chste Priorit√§t des Projekts

Das Feld `:properties` ist das **wissenschaftliche Vertrauenskapital** dieser Bibliothek.  
Jede neue Testfunktion gilt erst dann als fertig und merge-f√§hig, wenn **alle** folgenden Bedingungen erf√ºllt sind:

1. **Vollst√§ndigkeit**  
   Alle relevanten Eigenschaften aus den Quellen (Jamil & Yang, al-roomi, BBOB, CEC, etc.) sind √ºbernommen.

2. **Widerspruchsfreiheit**  
   Keine logischen Konflikte, z. B.:  
   - `convex` + `multimodal` / `non-convex` / `deceptive`  
   - `differentiable` + `partially differentiable`  
   - `differentiable` + `has_noise`  
   - `unimodal` + `multimodal`  
   - `bounded` + `finite_at_inf` (redundant)

3. **Konformit√§t mit der Community-Konvention**  
   Die Properties entsprechen exakt der in BBOB, CEC, CUTEst, Jamil & Yang 2013, al-roomi.org usw. verwendeten Bedeutung ‚Äì auch wenn sie teilweise von der strengen mathematischen Definition abweichen (z. B. `partially differentiable` als ‚Äûfast √ºberall differenzierbar‚Äú).

**Automatisierte Pr√ºfung**  
Der Test `@testset "Property Consistency Checks"` in `test/runtests.jl` pr√ºft dies **automatisch und symmetrisch**.  
Ein einziger Versto√ü f√ºhrt zum **sofortigen Scheitern der gesamten Test-Suite** und blockiert den Merge (CI fail).

**Fazit**  
Der Property-Consistency-Test ist der **strengste Test** dieses Projekts.  
Er darf **niemals** rot sein ‚Äì auch nicht bei nur einem Versto√ü.


### [RULE_NAME_CONSISTENCY] MUST (aktualisiert 28.11.2025)
Der Funktionsname MUSS exakt dem Dateinamen (ohne .jl) entsprechen.
Beispiele:
  Datei:   rosenbrock.jl     ‚Üí Name: "rosenbrock"
  Datei:   venter_sobiezcczanski_sobieski.jl ‚Üí Name: "venter_sobiezcczanski_sobieski"

‚Üí NICHT mehr erlaubt:
  - basename(@__FILE__)[1:end-3]
  - func_name = ...
  - $(func_name) in Strings

Stattdessen:
  - Hartkodierter Name im Meta-Dict:   :name => "rosenbrock",
  - In Fehlermeldungen direkt:         "rosenbrock requires ..."
  - Oder (optional):                   "$(tf.meta[:name]) requires ..."

### [RULE_NO_BASENAME] MUST (neu seit 28.11.2025)
Der Aufruf `basename(@__FILE__)` ist **verboten** ‚Äì in jeder Form.
Grund: Verhindert Precompilation, erzeugt Cache-Geister, unsauber.
‚Üí L√∂sche jede Zeile, die `basename(@__FILE__)` enth√§lt.

### [RULE_NO_FUNC_NAME] MUST (neu seit 28.11.2025)
Die Hilfsvariable `func_name = ...` ist **verboten**.
Grund: Redundant, unsauber, war nur ein Workaround f√ºr basename.
‚Üí L√∂sche alle `func_name = ...`-Zeilen.
‚Üí Ersetze `$(func_name)` durch den hartkodierten Namen oder `tf.meta[:name]`.

### [RULE_PRECOMPILE_TRUE] MUST (neu seit 28.11.2025)
Das Paket muss mit `__precompile__(true)` laufen.
‚Üí Wenn Precompilation fehlschl√§gt ‚Üí Code ist falsch.
‚Üí Keine Ausreden mehr mit `__precompile__(false)`.

### [RULE_GRADIENT_ACCURACY_TEST] SHOULD (empfohlen)
Wenn der Gradient-Accuracy-Test bei einer Funktion **systematisch** scheitert
(z. B. `mishra9`, `venter_sobiezcczanski_sobieski`), weil numerische Ableitung
bei gro√üen Werten versagt:
‚Üí F√ºge im Test eine Ausnahme hinzu:
```julia
if tf.name in ["mishra9", "venter_sobiezcczanski_sobieski"]
    continue
end

## Schritt 2: Implementierung

## üìù [RULE_CONST_TYPE_CAST] MUST: Konstanten-Typisierung

Um **Pr√§zisionsverlust** bei h√∂herer Rechengenauigkeit (z.B. `BigFloat`) zu vermeiden und die volle Generizit√§t zu gew√§hrleisten, **M√úSSEN** alle numerischen Konstanten (wie `20.0`, `0.2`, `2*œÄ`, `exp(1)` etc.) im Funktionsk√∂rper **explizit** in den generischen Elementtyp `T` gecastet werden.

### ‚ùå Anti-Pattern (FALSCH)

function ackley(x::AbstractVector)
    T = eltype(x)
    a = 20.0       # ‚ùå Float64 Literal, verliert Genauigkeit bei BigFloat
    b = 0.2
    c = 2 * œÄ
    # ...
    return ... + a + exp(1) # ‚ùå exp(1) ist Float64
end

### ‚úÖ Richtiges Muster

function <name>(x::AbstractVector)
    T = eltype(x)
    # ...
    # ‚úÖ Explizites Casting auf den Typ T
    a = T(20.0)
    b = T(0.2)
    c = T(2) * T(œÄ)

    # ‚úÖ Die Konstante e explizit im Typ T verwenden
    e_val = T(MathConstants.e) 

    return -a * exp(-b * sqrt(sum_squares)) - exp(sum_cos) + a + e_val
end

> HINWEIS: Die Verwendung von `T(MathConstants.e)` stellt sicher, dass der Wert der Eulerschen Zahl 'e' mit der durch `T` geforderten Genauigkeit berechnet wird.

---



 - [RULE_NO_MODULE] MUST: Kein module ... end in src/functions/*.jl. Wird via include geladen.
 - [RULE_SIGNATURE] MUST: Funktionssignatur: function <name>(x::AbstractVector<T>) where {T<:Union{Real, ForwardDiff.Dual, BigFloat}}. Export: export <UPPER>_FUNCTION, <name>, <name>_gradient. (Neu: BigFloat f√ºr h√∂here Rechengenauigkeit; siehe [RULE_HIGH_PREC_SUPPORT] SHOULD: Erweitere Signatur um BigFloat f√ºr optionale High-Precision-Berechnungen. Nutzer k√∂nnen BigFloat.(x) eingeben; Standard Float64 bleibt unver√§ndert schnell.)
 - [RULE_NAME_CONSISTENCY] MUST: Der gew√§hlte, kleingeschriebene Funktionsname (`<name>`) MUST in allen folgenden Artefakten konsistent verwendet werden: Dateiname (`<name>.jl`), Funktionssignatur (`function <name>`), Gradientensignatur (`function <name>_gradient`), exportierte Konstante (`<UPPERCASE>_FUNCTION`), und im `:name`-Meta-Feld (exakt der Dateiname ohne Extension, klein, ohne Leerzeichen). | Z. B. Datei `schaffer1.jl` ‚Üí `schaffer1`, `schaffer1_gradient`, `SCHAFFER1_FUNCTION`, `:name => "schaffer1"`.  F√ºr Einfachheit: Hartkodierte Strings in Errors/Meta (z.B. :name => "schaffer1"); vermeide basename [NEW RULE_AD_COMPATIBILITY]. Automatisierbar: `:name => "<name>"`. H√§ufiger Fehler: Tippfehler wie "shaffer" vs. "schaffer" ‚Äì pr√ºfe mit `grep -r "<name>" src/` vor Commit. Optional: @assert "<name>" == basename(@__FILE__)[1:end-3] f√ºr Validierung.
 - [RULE_NAME_CONSISTENCY] SHOULD: In Fehlermeldungen (z. B. ArgumentError) den exakten `<name>` verwenden, um Konsistenz zu wahren. F√ºr lesbare Anzeigen (z.B. in Docs/Print-Funktionen) eine separate Formatierung nutzen (z. B. titlecase(`<name>`)). | Z. B. `throw(ArgumentError("<name> requires exactly 2 dimensions"))` ‚Äì hartkodiert konsistent. In `print_function_properties.jl`: "Schaffer1" via String-Manipulation. F√ºr skalierbare: Gleiche Regel (z. B. `:name => "ackley"`).
 - [RULE_ERROR_TEXT_DYNAMIC] SHOULD: In allen Fehlermeldungen (z. B. ArgumentError f√ºr Dimension, NaN/Inf-Handling) den exakten <name> verwenden (hartkodiert, z.B. "<name> requires exactly <DIM> dimensions"). F√ºr maximale Einfachheit: Statische Strings; Dynamik via let optional, aber vermeide basename in f/grad [NEW RULE_AD_COMPATIBILITY]. Automatisierbar: CI-Check mit Regex auf "<name> requires" in <name>.jl.
 - [RULE_GRADTYPE] MUST: Gradient als Vector<T> (z.B. zeros(T, n)). Kein SVector.
 - [RULE_NO_CONST_ARRAYS] MUST: Keine globalen const-Arrays. Lokale let-Bl√∂cke f√ºr Caching. Wiederholung: Vermeide globale Konstanten.
 - [RULE_ERROR_HANDLING] MUST: Pr√ºfe length(x)==0 ‚Üí ArgumentError. Handle NaN/Inf (return NaN/Inf).
 - SHOULD: Verwende @inbounds f√ºr Loops; pr√ºfe @code_warntype f√ºr Type-Stability.
 - [RULE_TYPE_CONVERSION_MINIMAL] SHOULD: Vermeide redundante explizite Typ-Konvertierungen wie `T(0.5)` oder `T(1.0)` in Ausdr√ºcken, da Julia die Inferenz korrekt durchf√ºhrt (T ist Subtyp von Real). Verwende stattdessen `0.5` oder `1.0`. Dies verbessert Type-Stability und vermeidet unn√∂tigen Overhead. Beispiel: `numerator = sin(sq_sum)^2 - T(0.5)` ‚Üí `numerator = sin(sq_sum)^2 - 0.5`. Pr√ºfe mit `@code_warntype tf.f([1.0, 1.0])` ‚Äì sollte keine Type-Instabilit√§ten zeigen. F√ºr Integer-Konstanten in Multiplikationen (z.B. 4 * x): Verwende T(4) * x f√ºr BigFloat-Stabilit√§t, aber nur wenn n√∂tig (SHOULD: Teste mit @code_warntype bei BigFloat-Input).
 - [RULE_HIGH_PREC_SUPPORT] SHOULD: F√ºr h√∂here Rechengenauigkeit erweitere die Signatur um BigFloat in where-Klausel und verwende T(k) f√ºr Integer-Konstanten. F√ºge optional if T <: BigFloat; setprecision(256); end nach Edge-Cases hinzu. Validiere mit @code_warntype tf.f(BigFloat.(rand(n))).
 -  [RULE_LOCAL_HELPERS_NAMING] MUST: Alle lokalen Hilfsfunktionen in `src/functions/<name>.jl` (z. B. f√ºr Komponenten wie Shubert-Produkt oder Rastrigin-Summe) M√úSSEN mit einem Pr√§fix benannt werden, das den Dateinamen enth√§lt und einen Unterstrich (z. B. `_<name>_component` oder `_<name>_inner`). Dies verhindert Namenskonflikte mit exportierten Funktionen aus anderen Dateien, da `include` den Namespace teilt.  
   - Beispiel: In `shubert_hybrid_rastrigin.jl` ‚Üí `_shubert_hybrid_rastrigin_inner` statt `shubert_inner`; `_shubert_hybrid_rastrigin_rastrigin_component` statt `rastrigin`.  
   - Automatisierbar: Verwende statische Pr√§fixe f√ºr Klarheit.  
   - H√§ufiger Fehler: Lokale `rastrigin`-Funktion kollidiert mit globaler `rastrigin` aus `rastrigin.jl`, f√ºhrt zu falschem Dispatch in Tests (z. B. `cos(Inf)`-Fehler).  
   - CI-Check: F√ºge zu CI-Skripten hinzu: `grep -r "function [a-zA-Z]" src/functions/ | grep -v "_.*_"` ‚Üí warnt bei fehlenden Pr√§fixen.
 -  [RULE_LOCAL_HELPERS_ERROR_HANDLING] MUST: Lokale Hilfsfunktionen M√úSSEN die gleichen Edge-Case-Checks wie die Hauptfunktion implementieren (leeres Array, NaN, Inf), um konsistente Fehlerbehandlung zu gew√§hrleisten. Returniere `T(NaN)` f√ºr NaN-Inputs und `T(Inf)` f√ºr Inf-Inputs **vor** mathematischen Operationen (z. B. `cos`), um DomainErrors zu vermeiden.  
   - SHOULD: F√ºr skalierbare Hilfsfunktionen: Pr√ºfe `n < 1` und wirf `ArgumentError`.  
   - Beispiel: 
      function _shubert_hybrid_rastrigin_rastrigin_component(x::AbstractVector<T>) where {T}
          n = length(x)
          n == 0 && throw(ArgumentError("Input vector cannot be empty"))
          any(isnan.(x)) && return T(NaN)
          any(isinf.(x)) && return T(Inf)  # Vor cos(2*pi*x[i])
          # ... Rest der Funktion
      end
   - H√§ufiger Fehler: Fehlender Inf-Check f√ºhrt zu `DomainError` in `cos(Inf)`, was Tests wie `@test isinf(f([Inf]))` scheitern l√§sst.  
   - Automatisierte Validierung: Erweitere REPL-Checks: `julia --project=. -e 'include("src/functions/<name>.jl"); @test_throws ArgumentError <local_helper>(Float64[]); @test isinf(<local_helper>([Inf]))'`.
 - MAY: F√ºr Matrizen: A = Diagonal(fill(2.0, n)); pr√ºfe eigvals(A) > 0.
 - [RULE_META_CALL] SHOULD: In Meta-Dict: F√ºr skalierbare, aber konstante Werte (z.B. :min_value), (n::Int) -> value verwenden (ignoriere n). Beispiel f√ºr Qing: :min_value => (n::Int) -> 0.0.  F√ºr noisy konstante Minima: Deterministischer Teil als (n::Int) -> value; Noise in :description.
 -  F√ºr skalierbare Funktionen: F√ºge :default_n => <int> hinzu (siehe [RULE_DEFAULT_N]). Verwende es konsistent in Templates und Tests. MUST: Passe die Templates an, um [RULE_ERROR_TEXT_DYNAMIC] und [RULE_TYPE_CONVERSION_MINIMAL] einzubauen ‚Äì siehe aktualisierte Templates unten.
[NEW RULE_START_AWAY_FROM_MIN] MUST: Der Startpunkt (:start) MUSS vom globalen Minimum (:min_position) entfernt sein, um realistische Optimierungs-Tests zu erm√∂glichen. Validiere: f(start) > min_value + 1.0 (oder >> f√ºr multimodale) und ||grad(start)|| > 1e-6. F√ºr Funktionen mit Minimum bei zeros(n) (z.B. wavy): Verwende fill(1.0, n) oder rand(lb, ub). Dokumentiere in :description, falls Start bounds-verletzend ist. Beispiel: Bei wavy (min bei 0): :start => fill(1.0, n); f(start) ‚âà1.509 > 0.
- Validierung: In test/<name>_tests.jl: @test tf.f(start_point) > tf.meta[:min_value](n) + 1e-3
- H√§ufiger Fehler: Start = min_pos ‚Üí Optimierer "erfolgreich" in 0 Iterationen; CI-Check: @test !all(start_point .‚âà min_pos, atol=1e-6)

Template f√ºr src/functions/<name>.jl (non-scalable, z.B. Biggs EXP3, n=3):

# src/functions/<name>.jl
# Purpose: Implementation of the <Full Name> test function.
# Global minimum: f(x*)=<value> at x*=<pos>.
# Bounds: <lb> ‚â§ x_i ‚â§ <ub>.

export <UPPERCASE>_FUNCTION, <name>, <name>_gradient

function <name>(x::AbstractVector<T>) where {T<:Union{Real, ForwardDiff.Dual, BigFloat}}
    n = length(x)
    n == 0 && throw(ArgumentError("Input vector cannot be empty"))
    n != <DIM> && throw(ArgumentError("<name> requires exactly <DIM> dimensions"))  # Hartkodiert [UPDATED RULE_ERROR_TEXT_DYNAMIC]
    any(isnan.(x)) && return T(NaN)
    any(isinf.(x)) && return T(Inf)
    
    # Optional: High-Prec Pr√§zision setzen (nur bei BigFloat)
    if T <: BigFloat
        setprecision(256)  # Passe an gew√ºnschte Bits an; [RULE_HIGH_PREC_SUPPORT]
    end
    
    # Optimierte lokale Berechnung: Arrays direkt in Schleife generieren, um let-Block zu vermeiden [RULE_NO_CONST_ARRAYS]
    #  Beispiel f√ºr lokale Hilfsfunktion mit Pr√§fix: function _<name>_local_helper(...) ... end
    sum_sq = zero(T)
    @inbounds for i in 1:<LOOP_SIZE>
        t_i = 0.1 * i  # Dynamisch berechnen statt pre-allocated Array
        y_i = exp(-t_i) - 5 * exp(-10 * t_i)
        e_i = exp(-t_i * x[1]) - x[3] * exp(-t_i * x[2]) - y_i
        sum_sq += e_i^2
    end
    sum_sq
end

function <name>_gradient(x::AbstractVector<T>) where {T<:Union{Real, ForwardDiff.Dual, BigFloat}}
    n = length(x)
    n == 0 && throw(ArgumentError("Input vector cannot be empty"))
    n != <DIM> && throw(ArgumentError("<name> requires exactly <DIM> dimensions"))  # Hartkodiert [UPDATED RULE_ERROR_TEXT_DYNAMIC]
    any(isnan.(x)) && return fill(T(NaN), n)
    any(isinf.(x)) && return fill(T(Inf), n)
    
    # Optional: High-Prec Pr√§zision setzen (nur bei BigFloat)
    if T <: BigFloat
        setprecision(256)  # Passe an gew√ºnschte Bits an; [RULE_HIGH_PREC_SUPPORT]
    end
    
    grad = zeros(T, <DIM>)  # [RULE_GRADTYPE]
    # ... Gradient-Implementierung, z.B. ohne redundante T(1.0) [RULE_TYPE_CONVERSION_MINIMAL] ...
    #  Lokale Hilfsfunktion mit Edge-Checks: function _<name>_grad_helper(...) ... end
    @inbounds for i in 1:n
        # ...
    end
    grad
end

const <UPPERCASE>_FUNCTION = TestFunction(
    <name>,
    <name>_gradient,
    Dict{Symbol, Any}(
        :name => "<name>",  # Hartkodiert [RULE_NAME_CONSISTENCY]
        :description => "<Beschreibung; Properties based on [Direkte Quelle, z.B. Jamil & Yang (2013, p. 15)]; urspr√ºnglich aus [Mutma√üliche Ursprungsquelle, falls bekannt]>.",
        :math => raw"""f(\mathbf{x}) = <LaTeX>. """,
        :start => () -> [<start1>, ...],  # F√ºr scalable: (n::Int) -> ...
        :min_position => () -> [<pos1>, ...],
        :min_value => () -> <value>,  # F√ºr konstante Werte: Immer () -> value, auch bei scalable
        :properties => ["<prop1>", ...],
        :source => "<Direkte Quelle, z.B. Jamil & Yang (2013, p. 15)>",
        :lb => () -> [<lb1>, ...],
        :ub => () -> [<ub1>, ...],
    )
)

# Optional: Validierung beim Laden
@assert "<name>" == basename(@__FILE__)[1:end-3] "<name>: Dateiname mismatch!"

F√ºr scalable: Ersetz () -> [...] durch (n::Int) -> begin n<1 && throw(ArgumentError("<name> requires at least 1 dimension")); fill(<val>, n) end. F√ºge "scalable" zu properties.  Beispiel-Anpassung f√ºr Qing: :min_value => (n::Int) -> 0.0 (konstant), :min_position => (n::Int) -> sqrt.(1:n). F√ºge :default_n => 2 hinzu.

Template f√ºr src/functions/<name>.jl (scalable, z.B. Qing):

# src/functions/<name>.jl
# Purpose: Implementation of the <Full Name> test function.
# Global minimum: f(x*)=<value> at x*=... (n-dependent).
# Bounds: <lb> ‚â§ x_i ‚â§ <ub>.

export <UPPERCASE>_FUNCTION, <name>, <name>_gradient

function <name>(x::AbstractVector<T>) where {T<:Union{Real, ForwardDiff.Dual, BigFloat}}
    n = length(x)
    n == 0 && throw(ArgumentError("Input vector cannot be empty"))
    n < 1 && throw(ArgumentError("<name> requires at least 1 dimension"))  # Hartkodiert, angepasst f√ºr scalable [UPDATED RULE_ERROR_TEXT_DYNAMIC]
    any(isnan.(x)) && return T(NaN)
    any(isinf.(x)) && return T(Inf)
    
    # Optional: High-Prec Pr√§zision setzen (nur bei BigFloat)
    if T <: BigFloat
        setprecision(256)  # Passe an gew√ºnschte Bits an; [RULE_HIGH_PREC_SUPPORT]
    end
    
    sum_sq = zero(T)
    @inbounds for i in 1:n
        diff = x[i]^2 - i
        sum_sq += diff^2
    end
    sum_sq
end

function <name>_gradient(x::AbstractVector<T>) where {T<:Union{Real, ForwardDiff.Dual, BigFloat}}
    n = length(x)
    n == 0 && throw(ArgumentError("Input vector cannot be empty"))
    n < 1 && throw(ArgumentError("<name> requires at least 1 dimension"))  # Hartkodiert [UPDATED RULE_ERROR_TEXT_DYNAMIC]
    any(isnan.(x)) && return fill(T(NaN), n)
    any(isinf.(x)) && return fill(T(Inf), n)
    
    # Optional: High-Prec Pr√§zision setzen (nur bei BigFloat)
    if T <: BigFloat
        setprecision(256)  # Passe an gew√ºnschte Bits an; [RULE_HIGH_PREC_SUPPORT]
    end
    
    grad = zeros(T, n)  # [RULE_GRADTYPE]
    @inbounds for i in 1:n
        diff = x[i]^2 - i
        grad[i] = 4 * x[i] * diff  # Vereinfachte Konstanten: 4 statt T(4) [RULE_TYPE_CONVERSION_MINIMAL]
    end
    grad
end

const <UPPERCASE>_FUNCTION = TestFunction(
    <name>,
    <name>_gradient,
    Dict{Symbol, Any}(
        :name => "<name>",  # Hartkodiert [RULE_NAME_CONSISTENCY]
        :description => "<Beschreibung; Properties based on [Direkte Quelle, z.B. Jamil & Yang (2013, p. 29)]; Multiple global minima due to sign choices; urspr√ºnglich aus [Mutma√üliche Ursprungsquelle, falls bekannt]>.",
        :math => raw"""f(\mathbf{x}) = \sum_{i=1}^D (x_i^2 - i)^2.""",
        :start => (n::Int) -> begin n < 1 && throw(ArgumentError("<name> requires at least 1 dimension")); zeros(n) end,
        :min_position => (n::Int) -> begin n < 1 && throw(ArgumentError("<name> requires at least 1 dimension")); sqrt.(1:n) end,
        :min_value => (n::Int) -> 0.0,  # Konstant: (n::Int) -> value [RULE_META_CONSISTENCY]
        :default_n => 2,  # Kleinste n >1; hier 2 f√ºr allgemein skalierbar [RULE_DEFAULT_N]
        :properties => ["continuous", "differentiable", "separable", "scalable", "multimodal"],
        :source => "<Direkte Quelle, z.B. Jamil & Yang (2013, p. 29)>",
        :lb => (n::Int) -> begin n < 1 && throw(ArgumentError("<name> requires at least 1 dimension")); fill(<lb>, n) end,
        :ub => (n::Int) -> begin n < 1 && throw(ArgumentError("<name> requires at least 1 dimension")); fill(<ub>, n) end,
    )
)

# Optional: Validierung beim Laden
@assert "<name>" == basename(@__FILE__)[1:end-3] "<name>: Dateiname mismatch!"

## Tests und Validierung
Ziel: Zentrale Tests + funktionsspezifisch in test/<name>_tests.jl.

 - [RULE_ATOL] SHOULD: atol=1e-3 f√ºr Start/Extra, 1e-8 f√ºr Minima.  F√ºr has_noise: Kein atol; Range-Check (z.B. 0 <= f <1). Neu: F√ºr High-Prec-Tests (BigFloat): Verwende atol=1e-15 oder h√∂her; teste mit BigFloat-Inputs in optionalem Test-Block.
 - MUST: Einbinden via include("test/<name>_tests.jl") in include_testfiles.jl.
 - SHOULD: Berechne Test-Werte exakt via REPL (z.B. tf.f(start_point)).  F√ºr Noise: Multiple Evaluations (z.B. mean([tf.f(min_pos) for _ in 1:10]) ‚âà deterministischer Wert). F√ºr BigFloat: Teste tf.f(BigFloat.(min_pos)) ‚âà BigFloat(min_value) atol=BigFloat("1e-15").
 - [RULE_TEST_SYNTAX] MUST: F√ºr Vektor-Vergleiche: Verwende all(isapprox.(vec, target, atol=1e-8)) statt all(vec .‚âà target, atol=1e-8) ‚Äì letzteres wirft MethodError, da all() atol ignoriert. F√ºr Skalare: x ‚âà y atol=1e-8. F√ºr BigFloat: isapprox mit BigFloat-atol.
[NEW RULE_TESTFILE_LOADING] MUST: In test/include_testfiles.jl (oder test/include_testfiles.jl, falls in test/): 
 - F√ºge `using NonlinearOptimizationTestFunctions` **nach** den anderen using-Statements (z.B. using Test, ForwardDiff, ...) und **vor** allen include-Statements hinzu. Dies gew√§hrleistet, dass alle exportierten Konstanten (z.B. <UPPER>_FUNCTION) global im Scope verf√ºgbar sind, bevor die Testdateien geladen werden. 
 - F√ºr Pfad-Konsistenz: Wenn include_testfiles.jl in src/ liegt, verwende `include("../test/<name>_tests.jl")`; wenn in test/, verwende `include("<name>_tests.jl")`.
 - Automatisierbar: Erstelle ein Skript (z.B. examples/generate_includes.jl), das dynamisch Includes generiert und das using pre-pendet.
 - H√§ufiger Fehler: UndefVarError f√ºr <UPPER>_FUNCTION ‚Äì L√∂sung: Pre-load das Paket, um Scope-Kollisionen in runtests.jl zu vermeiden.
 - Validierung: In runtests.jl: Nach include("include_testfiles.jl"), teste `@test isdefined(Main, :TRIGONOMETRIC2_FUNCTION)` f√ºr neu hinzugef√ºgte Funktionen.
 -  Meta-Aufruf im Test: Passe Aufruf an Signatur an: Wenn () -> ..., dann tf.meta[:min_value](); wenn (n::Int) -> ..., dann tf.meta[:min_value](n).
 -  F√ºr skalierbare: Verwende n = tf.meta[:default_n] in Tests f√ºr Standard-Validierungen (z.B. min_pos = tf.meta[:min_position](n)).
 - [NEW RULE_NOISE_VALIDATION] MUST: In funktionsspezifischen Tests und runtests.jl: F√ºr "has_noise": @test f_min >= min_value && f_min < min_value + noise_upper (z.B. <1 f√ºr [0,1)). 
 -  [RULE_PROPERTIES_DYNAMIC_COUNT] SHOULD: In `test/runtests.jl` die Properties-Z√§hlungen dynamisch berechnen und nur als Info ausgeben, statt harte `@test`-Asserts (z.B. `println("Bounded functions: ", length(filter_testfunctions(tf -> has_property(tf, "bounded"))))`). Bei Hinzuf√ºgen neuer Funktionen: Aktualisiere manuell oder automatisiere via Skript (`generate_properties_counts.jl`).  
   - MUST: Nach jedem Commit: F√ºhre `julia --project=. -e 'using NonlinearOptimizationTestFunctions; open("test/properties_counts.jl", "w") do f; println(f, "export BOUNDED_COUNT = ", length(filter_testfunctions(...))) end'` aus.  
   - H√§ufiger Fehler: Harte Zahlen (z. B. 127 vs. 128) brechen bei neuen Funktionen (wie `shubert_hybrid_rastrigin` mit "bounded").  
   - Vorteil: Macht Tests wartbar; CI kann Counts validieren.
 -  Name-Validierung: In test/<name>_tests.jl: @test tf.meta[:name] == "<name>" && occursin("<name> requires", @code_string(<name>([1.0]))) (via try-catch f√ºr Error-Text). Neu: Optionaler High-Prec-Test: @test tf.f(BigFloat.(min_pos)) ‚âà BigFloat(min_value) atol=BigFloat("1e-15").

Template f√ºr test/<name>_tests.jl (non-scalable):

# test/<name>_tests.jl

using Test, NonlinearOptimizationTestFunctions
@testset "<name>" begin
    tf = <UPPERCASE>_FUNCTION
    @test tf.meta[:name] == "<name>"  # Hartkodiert [RULE_NAME_CONSISTENCY]
    @test has_property(tf, "<prop1>")  # F√ºr jede Property
    
    start_point = tf.meta[:start]()
    @test tf.f(start_point) ‚âà <computed> atol=1e-3
    
    min_pos = tf.meta[:min_position]()
    @test tf.f(min_pos) ‚âà tf.meta[:min_value]() atol=1e-8  # Passe an: () oder (n); f√ºr Noise: Range-Check
    
    # Optional: High-Prec-Validierung [RULE_HIGH_PREC_SUPPORT]
    # using BigFloat; setprecision(256); @test tf.f(BigFloat.(min_pos)) ‚âà BigFloat(tf.meta[:min_value]()) atol=BigFloat("1e-15")
end

Template f√ºr test/<name>_tests.jl (scalable, z.B. Qing):

# test/<name>_tests.jl

using Test, NonlinearOptimizationTestFunctions
@testset "<name>" begin
    tf = <UPPERCASE>_FUNCTION
    @test tf.meta[:name] == "<name>"  # Hartkodiert [RULE_NAME_CONSISTENCY]
    @test has_property(tf, "<prop1>")  # F√ºr jede Property
    
    n = tf.meta[:default_n]  # Verwende default_n f√ºr Standard-Tests
    @test n >= 2
    
    start_point = tf.meta[:start](n)
    @test length(start_point) == n
    @test all(start_point .== 0)  # Beispiel-Check
    
    min_pos = tf.meta[:min_position](n)
    @test tf.f(min_pos) ‚âà tf.meta[:min_value](n) atol=1e-8  # min_value mit (n), min_position mit (n); f√ºr Noise: Range-Check
    
    # Extra: Check another minimum
    min_pos_neg = [-sqrt(1.0), sqrt(2.0)]
    @test tf.f(min_pos_neg) ‚âà 0.0 atol=1e-8
    
    # Optional: High-Prec-Validierung [RULE_HIGH_PREC_SUPPORT]
    # using BigFloat; setprecision(256); @test tf.f(BigFloat.(min_pos)) ‚âà BigFloat(tf.meta[:min_value](n)) atol=BigFloat("1e-15")
end

Template f√ºr test/include_testfiles.jl (zentraler Test-Loader):

# test/include_testfiles.jl
# Purpose: Includes all function-specific test files for NonlinearOptimizationTestFunctions.
# Context: Part of the test suite, enables modular test loading for individual test functions.
# Last modified: [Datum]

using Test, ForwardDiff, Optim, Zygote, InteractiveUtils  # Basis-Deps
using NonlinearOptimizationTestFunctions  # [NEW RULE_TESTFILE_LOADING]: Pre-load Paket f√ºr globale Scope (TF_FUNCTIONs)

# Includes (alphabetisch sortiert; dynamisch generierbar via Skript)
include("ackley_tests.jl")
include("booth_tests.jl")
# ... (alle <name>_tests.jl)
include("trigonometric2_tests.jl")
include("tripod_tests.jl")

# Optional: Dynamische Validierung
@test all([isdefined(Main, symbol("$TF_FUNCTION")) for TF in ["TRIGONOMETRIC2", "TRIPOD"]])  # Scope-Check f√ºr neue Funktionen

 F√ºr noisy Funktionen (z.B. Quartic): Erweitere Template um:
    f_min = tf.f(min_pos)
    @test f_min >= 0 && f_min < 1  # F√ºr [0,1)-Noise

 Update f√ºr runtests.jl "Minimum Validation" Testset (f√ºge nach min_value-Zeile ein):
    if "has_noise" in tf.meta[:properties]
        @test f_val >= min_value && f_val < min_value + 1.0  # Beispiel f√ºr [0,1); passe an Noise an
    else
        @test f_val ‚âà min_value atol=1e-6
    end

## TestFunction-Struktur [RULE_TESTFUNCTION_FIELDS]

Die TestFunction-Struktur hat folgende Felder:
 - f: Die Zielfunktion (erster Parameter im Konstruktor)
 - grad: Die Gradientenfunktion (zweiter Parameter im Konstruktor)
 - meta: Dictionary mit Metadaten

WICHTIG: In Tests verwendet man tf.grad(x), NICHT tf.gradient(x)!

Hinweis zur Namenskonvention: Der Funktionsname endet auf _gradient (z.B. price1_gradient), aber das Struct-Feld hei√üt grad. Dies ist eine Designentscheidung des Pakets - der l√§ngere Name verhindert Namenskonflikte, w√§hrend das kurze Feld praktischer im Zugriff ist.

Beispiel:

# Funktion definieren
function myfunction_gradient(x) ... end

# TestFunction erstellen
const MYFUNCTION_FUNCTION = TestFunction(
    myfunction,
    myfunction_gradient,  # ‚Üê wird zu tf.grad
    Dict(...)
)

# In Tests verwenden
grad = tf.grad([1.0, 2.0])  # ‚úÖ Korrekt
grad = tf.gradient([1.0, 2.0])  # ‚ùå Fehler!

## Schritte-Checkliste (mit Regeln)
1. Recherche: Validiere Properties [RULE_PROPERTIES_SOURCE] ‚Äì notiere spezifische Stelle (z.B. Seite) in :source. F√ºr scalable: Bestimme :default_n [RULE_DEFAULT_N].  F√ºr noisy: Definiere Noise-Range in :description.
2. Implementiere src/functions/<name>.jl [RULE_SIGNATURE, RULE_NO_CONST_ARRAYS]. F√ºge :default_n hinzu.  F√ºr konstante min_value: (n::Int) -> value. Verwende direkte Quelle mit Stelle in :source.  Lokale Hilfsfunktionen: Benenne mit Pr√§fix `_ <name> _ <zweck>` [RULE_LOCAL_HELPERS_NAMING]; f√ºge Edge-Checks hinzu [RULE_LOCAL_HELPERS_ERROR_HANDLING]. Neu: Validiere High-Prec mit @code_warntype tf.f(BigFloat.(rand(n))).
3. Syntax-Check: julia --project=. -e 'include("src/functions/<name>.jl")' [RULE_SYNTAXCHECK].  √úberpr√ºfe lokale Hilfsfunktionen: `@test_throws ArgumentError _<name>_helper(Float64[]); @test isinf(_<name>_helper([Inf]))`. Neu: Teste BigFloat: tf.f(BigFloat.([1.0])) ohne Error.
4. Tests: Schreibe test/<name>_tests.jl, einbinden.  REPL-Validierung: Lade tf, teste tf.meta[:min_value](tf.meta[:default_n]) ‚âà tf.f(tf.meta[:min_position](tf.meta[:default_n])) atol=1e-8; f√ºr Noise: Range-Check.  Dynamische Properties-Counts in runtests.jl [RULE_PROPERTIES_DYNAMIC_COUNT]. Neu: Optionaler High-Prec-Test-Block.
4. Tests: Schreibe test/<name>_tests.jl, einbinden.  √úberpr√ºfe in include_testfiles.jl: using NonlinearOptimizationTestFunctions vor includes; teste Scope mit @test isdefined(Main, :<UPPER>_FUNCTION).
5. Gesamttests: julia --project=. test/runtests.jl.  √úberpr√ºche Noise-Adaptation in Minimum Validation. Neu: Benchmark mit BigFloat: @btime tf.f(BigFloat.(rand(n))) <10Œºs.
6. Validierung: [ ] Properties aus Tabelle; [ ] Keine globalen const; [ ] Gradient als Vector<T>;  Keine MethodError in Meta-Aufrufen; [ ] Vektor-Tests mit isapprox..  :default_n >=2 und verwendet in Tests;  Noise-Handling in Tests/runtests.jl;  :source mit spezifischer Stelle (z.B. "Jamil & Yang (2013, p. 27)");  Lokale Hilfsfunktionen mit Pr√§fix und Edge-Checks;  Keine Namenskonflikte (grep -r "function <common_name>" src/). Neu: [ ] BigFloat-Support: tf.f(BigFloat.(min_pos)) ‚âà BigFloat(min_value) atol=1e-15.

Finale Validierung: Alle MUST-Regeln erf√ºllt? Benchmark mit @btime tf.f(rand(tf.meta[:default_n])) <1Œºs.  F√ºhre manuell: julia> tf = <UPPER>_FUNCTION; n = tf.meta[:default_n]; min_pos = tf.meta[:min_position](n); f√ºr Noise: multiple tf.f(min_pos) in [0,1); sonst @test tf.f(min_pos) ‚âà tf.meta[:min_value](n) atol=1e-8 ‚Äì passe Signatur an, falls Error. √úberpr√ºche :source auf direkte √úbernahme mit Stelle.  Pr√ºfe lokale Hilfsfunktionen: Kein Kollision (z.B. grep -r "function rastrigin" src/functions/ | grep -v "_.*_rastrigin"); Edge-Cases: `@test isinf(_<name>_helper([Inf]))`. Neu: @test tf.f(BigFloat.(min_pos)) ‚âà BigFloat(tf.meta[:min_value](n)) atol=BigFloat("1e-15").

[NEW RULE_GRADIENT_SYMPY_VERIFICATION] MUST f√ºr alle Funktionen mit analytischem Gradient:
Bevor eine neue Testfunktion als "fertig" markiert wird, MUSS der analytische Gradient mit SymPy (oder einem anderen symbolischen Differentiations-Tool) verifiziert werden.

**Begr√ºndung**:  
Numerische Tests (ForwardDiff/FiniteDiff) sind wertvoll, aber ein einziger Vorzeichenfehler, falscher Faktor oder vergessener Term f√ºhrt zu systematischen Abweichungen, die in numerischen Tests oft erst bei gro√üen Werten auffallen. Symbolische Differentiation liefert in < 0,01 Sekunden die exakte Wahrheit.

# KI-Anleitung: Testfunktion implementieren (v3.1)

**Ziel**: Maschinenlesbare Struktur f√ºr KI-Assistenten. Parse nach `[RULE_ID]`-Tags. Priorisiere MUST > SHOULD > MAY (RFC-2119). Jede Regel hat Code-Beispiel + Validierung.

**KI-Parser-Instruktionen**: 
 - Extrahiere [RULE_*], [ERROR_*], [TEMPLATE_*], [VALID_PROPERTIES]
 - Generiere Code mit [RULE_ID]-Kommentaren
 - Validiere via Code-Tools (REPL bevorzugen)
 - Bei Unsicherheit: Suche Tag, kopiere Beispiel

---

## Meta: Parsing-Strategie

[PARSE_STRATEGY] KI MUST:
1. Parse alle [RULE_*] als Dict: `{"ID": {"priority": "MUST|SHOULD|MAY", "example": "...", "validation": "..."}}`
2. Template-Wahl: IS scalable? ‚Üí [TEMPLATE_B], ELSE ‚Üí [TEMPLATE_A]
3. Code-Generierung: Ersetze Platzhalter, f√ºge [RULE_ID]-Kommentare hinzu
4. Validierung: Syntax ‚Üí Meta-Calls ‚Üí Edge-Cases ‚Üí Type-Stability ‚Üí Tests
5. Output: Code + Validierungs-Report (‚úÖ/‚ùå pro Regel)

---

## Schritt 1: Recherche & Datensammlung

[RULE_PROPERTIES_SOURCE] MUST: Sammle ALLE Daten vor Code-Generierung in Dict-Format:

# Template f√ºr Datensammlung (KI: Parse als Dict)
data = Dict(
    :name => "<name>",  # Kleinbuchstaben (z.B. "schaffer1")
    :dimensions => "fest n=<DIM>" | "scalable n>=<MIN_N>",
    :min_value => <VALUE>,  # Exakt (REPL-berechnet)
    :min_position => [<POS1>, <POS2>, ...],
    :bounds_lb => [<LB1>, ...],
    :bounds_ub => [<UB1>, ...],
    :start => [<START1>, ...],
    :source => "Autor (YEAR, p. XX)",  # MUST: Mit Seitenangabe!
    :properties => ["<prop1>", ...],  # Nur aus [VALID_PROPERTIES]
    :formula_latex => raw"<LaTeX>",  # Exakt aus Quelle
)

**Validierung**:
# KI MUST ausf√ºhren (Code-Tool):
@assert occursin(r"p\. \d+", data[:source]) "Quelle ohne Seite!"
@assert all(p in VALID_PROPERTIES for p in data[:properties]) "Ung√ºltige Property!"

---

[VALID_PROPERTIES] MUST: Nur folgende Properties verwenden (als Array f√ºr Parsing):

VALID_PROPERTIES = [
    "bounded", "continuous", "controversial", "convex", "deceptive", 
    "differentiable", "finite_at_inf", "fully non-separable", 
    "has_constraints", "has_noise", "highly multimodal", "multimodal", 
    "non-convex", "non-separable", "partially differentiable", 
    "partially separable", "quasi-convex", "scalable", "separable", 
    "strongly convex", "unimodal", "ill-conditioned"
]

[RULE_MISSING_PROPERTIES] MUST: Fehlende Properties ‚Üí :description, NICHT erfinden.

**Beispiel**:
:properties => ["continuous", "separable"],  # ‚úÖ Nur erlaubte
:description => "Contains absolute value terms."  # ‚úÖ In Description
# ‚ùå FALSCH: :properties => ["non-differentiable"]  # Existiert nicht!

---

[RULE_SOURCE_FORMULA_CONSISTENCY] MUST: Formel in Quelle == Implementierung. Bei Abweichung:

:description => "Adapted from Jamil & Yang (2013, p. 27) for variant without absolute value."

**Validierung** (SHOULD mit SymPy):
# KI Code-Tool (Python):
import sympy as sp
x1, x2 = sp.symbols('x1 x2')
impl = x1**2 + x2**2  # Implementierte Formel
quelle = x1**2 + x2**2  # Aus Quelle
assert sp.simplify(impl - quelle) == 0, "Formel-Mismatch!"
---

[NEW RULE_SCALABILITY_FORMULA_CONSISTENCY] MUST: Bei Funktionen, die in der Quelle als "scalable" markiert sind, √ºberpr√ºfe explizit, ob die Formel tats√§chlich alle Dimensionen n nutzt (z. B. Schleifen bis n oder n-abh√§ngige Terme). Wenn die Formel nur eine feste Anzahl von Variablen (z. B. x1 bis x6) verwendet und h√∂here x_i ignoriert, entferne "scalable" aus :properties und passe die Dimension auf die effektive feste n fest (z. B. n=6). Notiere die Abweichung in :description (z. B. "Marked as scalable in source, but formula only uses first 6 variables; adapted to fixed n=6"). Validiere im REPL: F√ºr n+1 teste, ob tf.f([x1...xn, xn+1]) == tf.f([x1...xn]) (sollte true sein, wenn nicht skalierbar). Beispiel: Watson-Funktion ‚Äì Quelle sagt scalable, aber Formel nur bis x6; entferne "scalable" und setze n=6. Automatisierbar: F√ºge zu CI-Skripten hinzu: F√ºr "scalable" in properties, teste tf.f(rand(n+1)) != tf.f(rand(n)) (mit tol f√ºr Noise).


---

[RULE_DEFAULT_N] MUST (scalable): :default_n >= 2, kleinste g√ºltige Dimension.

:default_n => 2   # ‚úÖ Allgemein skalierbar (Ackley, Qing)
:default_n => 4   # ‚úÖ Block-skalierbar (n%4==0, PowellSingular2)

**Validierung**:
# KI MUST ausf√ºhren:
@assert haskey(data, :default_n) "Scalable ohne :default_n!"
@assert data[:default_n] >= 2 ":default_n < 2!"

---

## Schritt 2: Implementierung

[RULE_NAME_CONSISTENCY] MUST: Name √ºberall identisch (Datei/Funktion/Export/:name):

# Datei: src/functions/<name>.jl
function <name>(x) ...  # ‚úÖ Gleich wie Datei
export <UPPER>_FUNCTION, <name>, <name>_gradient  # ‚úÖ Uppercase f√ºr Konstante
const <UPPER>_FUNCTION = TestFunction(..., Dict(:name => "<name>", ...))  # ‚úÖ Hartkodiert

**Anti-Pattern**:
# ‚ùå FALSCH:
# Datei: schaffer1.jl
function schaffer_1(x) ...  # Name-Mismatch!
:name => "Schaffer1"  # Statisch + Uppercase!

---

[RULE_ERROR_TEXT_DYNAMIC] SHOULD: Fehlermeldungen mit hartkodiertem Namen:

# ‚úÖ RICHTIG:
throw(ArgumentError("<name> requires exactly <DIM> dimensions"))

# ‚ùå FALSCH (optional vermeiden):
throw(ArgumentError("schaffer1 requires exactly 2 dimensions"))  # Tippfehler-Risiko!

---

[RULE_ERROR_HANDLING] MUST: Edge-Cases VOR mathematischen Operationen:

# Template (KI: Immer einf√ºgen):
n = length(x)
n == 0 && throw(ArgumentError("Input vector cannot be empty"))
n != <DIM> && throw(ArgumentError("<name> requires exactly <DIM> dimensions"))  # F√ºr non-scalable
# ODER:
n < 1 && throw(ArgumentError("<name> requires at least 1 dimension"))  # F√ºr scalable
any(isnan.(x)) && return T(NaN)
any(isinf.(x)) && return T(Inf)  # WICHTIG: Vor cos/sin/exp!

---

[RULE_NO_CONST_ARRAYS] MUST: Keine globalen const-Arrays:

# ‚ùå FALSCH...